\documentclass[10pt,a4paper]{article}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{tikz}
\usepackage{syntax}
\usepackage[
  % Farben fuer die Links
  colorlinks=true,         % Links erhalten Farben statt Kaeten
  % urlcolor=pdfurlcolor,    % \href{...}{...} external (URL)
  % filecolor=pdffilecolor,  % \href{...} local file
  % linkcolor=pdflinkcolor,  %\ref{...} and \pageref{...}
  % citecolor=pdfcitecolor,  %
  % Links
  raiselinks=true,			 % calculate real height of the link
  breaklinks,              % Links berstehen Zeilenumbruch
  backref=page,            % Backlinks im Literaturverzeichnis (section, slide, page, none)
  pagebackref=true,        % Backlinks im Literaturverzeichnis mit Seitenangabe
  verbose,
  hyperindex=true,         % backlinkex index
  linktocpage=true,        % Inhaltsverzeichnis verlinkt Seiten
  hyperfootnotes=false,     % Keine Links auf Fussnoten
  % Bookmarks
  bookmarks=true,          % Erzeugung von Bookmarks fuer PDF-Viewer
  bookmarksopenlevel=1,    % Gliederungstiefe der Bookmarks
  bookmarksopen=true,      % Expandierte Untermenues in Bookmarks
  bookmarksnumbered=true,  % Nummerierung der Bookmarks
  bookmarkstype=toc,       % Art der Verzeichnisses
  % Anchors
  plainpages=false,        % Anchors even on plain pages ?
  pageanchor=true,         % Pages are linkable
  % PDF Informationen
  pdftitle={TPL Notes},             % Titel
  pdfauthor={},            % Autor
  pdfcreator={LaTeX, hyperref, KOMA-Script}, % Ersteller
  %pdfproducer={pdfeTeX 1.10b-2.1} %Produzent
  pdfdisplaydoctitle=true, % Dokumententitel statt Dateiname im Fenstertitel
  % pdfstartview=FitH,       % Dokument wird Fit Width geaefnet
  pdfpagemode=UseOutlines, % Bookmarks im Viewer anzeigen
  pdfpagelabels=true,           % set PDF page labels
  % pdfpagelayout=TwoPageRight, % zweiseitige Darstellung: ungerade Seiten
  									 % rechts im PDF-Viewer
  %pdfpagelayout=SinglePage, % einseitige Darstellung
]{hyperref}
\usetikzlibrary{arrows,shapes,automata}
%\geometry{a4paper,left=20mm,right=20mm, top=2cm, bottom=2cm}

\begin{comment}
nützliche befehle
\stackrel{oben}{unten}
\mathcal \mathfrak \mathbb
\operatorname{operator}
\newcommand{\makroname}{ was das makro ausgibt }
\infer[name]{unten}{oben}
\end{comment}

\newcommand{\on}{\operatorname}
\newcommand{\I}{\mathfrak{I}}
\newcommand{\A}{\mathfrak{A}}

\begin{document}

\tableofcontents

\section{Syntax and Semantics}
$e$ is some expression.
$v$ is some value.
$T$ is some type.
$x$ is some variable.
rule names ending with a $*$ are optional and could be convenient but will often cause nondeterminism.
rule names ending with a $'$ introduce optional features but might cause some problems.
rules for different things might have the same name,
the section titles should be interpreted as namespaces.



\subsection{Boolean}
\[e ::= true | false | ¬ e | e ∧ e\]
\[v ::= true | false\]
\[T ::= Bool\]
\subsubsection{Contraction}

\infer[(NotTrue)]{¬true → false}{} \vspace{1em}
\infer[(NotFalse)]{¬false → true}{} \vspace{1em}
\infer[(AndTrue)]{true ∧ e → e}{} \vspace{1em}
\infer[(AndTrue*)]{e ∧ true → e}{} \vspace{1em}
\infer[(AndFalse)]{false ∧ e → false}{} \vspace{1em}
\infer[(AndFalse*)]{e ∧ false → false}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(Not)]{¬e → ¬e'}{e → e'} \vspace{1em}
\infer[(And)]{e ∧ e₀ → e' ∧ e₀}{e → e'} \vspace{1em}
\infer[(And*)]{e₀ ∧ e → e₀ ∧ e'}{e → e'} \vspace{1em}

\subsubsection{Types}
\infer[(True)]{true: Bool}{}  \vspace{1em}
\infer[(False)]{false: Bool}{} \vspace{1em}
\infer[(Not)]{¬e: Bool}{e: Bool} \vspace{1em}
\infer[(And)]{e₁ ∧ e₂: Bool}{e₁: Bool \hspace{1em} e₂: Bool} \vspace{1em}




\subsection{Arithmetic}
\[e ::= ⟨n⟩ | e + e\]
\[v ::= ⟨n⟩ \]
\[T ::= Num\]
\subsubsection{Contraction}

\infer[(Plus)]{⟨n⟩ + ⟨m⟩ → ⟨n + m⟩}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(PlusLeft)]{e + e₀ → e' ∧ e₀}{e → e'} \vspace{1em}
\infer[(PlusRight)]{v + e → v + e'}{e → e'} \vspace{1em}
\infer[(PlusRight*)]{e₀ + e → e₀ + e'}{e → e'} \vspace{1em}

\subsubsection{Types}
\infer[(Num)]{⟨n⟩: Num}{}  \vspace{1em}
\infer[(Plus)]{e₁ + e₂: Num}{e₁: Num \hspace{1em} e₂: Num} \vspace{1em}




\subsection{Conditionals}
These kinda require Arithmetics and Booleans as a base.
\[e ::= e == e | e ? e !! e\]
\subsubsection{Contraction}

\infer[(EqualTrue)]{⟨n⟩ == ⟨n⟩ → true}{} \vspace{1em}
\infer[(EqualTrue')]{v == v → true}{} \vspace{1em}
\infer[(EqualFalse)]{⟨n⟩ == ⟨m⟩ → false}{n \ne m} \vspace{1em}
\infer[(EqualFalse')]{ v₁ == v₂ → false}{v₁ \ne v₂} \vspace{1em}
\infer[(IfTrue)]{true ?? e₁ !! e₂ → e₁}{} \vspace{1em}
\infer[(IfFalse)]{false ?? e₁ !! e₂ → e₁}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(EqualLeft)]{e == e₀ → e' ∧ e₀}{e → e'} \vspace{1em}
\infer[(EqualRight)]{v == e → v == e'}{e → e'} \vspace{1em}
\infer[(EqualRight*)]{e₀ == e → e₀ == e'}{e → e'} \vspace{1em}
\infer[(If)]{e ?? e₁ !! e₂ → e' ?? e₁ !! e₂}{e → e'} \vspace{1em}

\subsubsection{Types}
\infer[(Equal)]{e₁ == e₂: Bool}{e₁: Num \hspace{1em} e₂: Num} \vspace{1em}
\infer[(Equal')]{e₁ == e₂: Bool}{e₁: T \hspace{1em} e₂: T} \vspace{1em}
\infer[(If)]{e ?? e₁ !! e₂: T}{e: Bool \hspace{1em} e₁: T \hspace{1em} e₂: T} \vspace{1em}
\infer[(IfTrue')]{e ?? e₁ !! e₂: T}{e →^* true \hspace{1em} e₁: T} \vspace{1em}
\infer[(IfFalse')]{e ?? e₁ !! e₂: T}{e →^* false \hspace{1em} e₂: T} \vspace{1em}




\subsection{Functions}
\[e ::= λx:T. e | e e | x\]
\[T ::= T → T\]
Be aware that the type of $x$ is usually skipped (erased) when not doing type checking.

\subsubsection{Contraction}
\infer[(Application)]{(λx. e) v → e[x/v]}{} \vspace{1em}
\infer[(Application*)]{(λx. e₁) e₂ → e₁[x/e₂]}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(ApplicationFunction)]{e e₀ → e' e₀}{e → e'} \vspace{1em}
\infer[(ApplicationArgument)]{v e → v e'}{e → e'} \vspace{1em}
\infer[(ApplicationArgument*)]{e₀ e → e₀ e'}{e → e'} \vspace{1em}
\infer[(Abstraction')]{(λx. e) → (λx. e')}{e → e'} \vspace{1em}


\subsubsection{Types}
type rules for variables do use a context $Γ$ if lambda calculus is combined with
some of the other rules you have to pass the context through all the other type rules.

\infer[(Variable)]{Γ \vdash x: T}{Γ(x) = T} \vspace{1em}
\infer[(Abstraction)]{Γ \vdash (λx:T. e): T → T'}{Γ, x: T \vdash e: T'} \vspace{1em}
\infer[(Application)]{Γ \vdash e₁ e₂: T'}{Γ \vdash e₁: T → T' \hspace{1em} Γ \vdash e₂: T'} \vspace{1em}



\subsection{Fixpoint}
\[e ::= fix(e)\]

\subsubsection{Contraction}
\infer[(Fixpoint)]{fix(e) → e[rec/fix(e)]}{} \vspace{1em}

\subsubsection{Types}
\infer[(Fixpoint)]{fix(e): T}{e: T \vdash T} \vspace{1em}



\subsection{Records}
\[e ::= \{l_i = e_i\} | e.l \]
\[v ::= \{l_i = v_i\}\]
\[T ::= \{l_i : T_i\}\]
Note that $l$ here means a label.
Also note that most things indexed with $i$ are assumed to quantify over all the possibilities.

\subsubsection{Contraction}
\infer[(Access)]{\{l_i = v_i\}.l_i → v_i}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(Record)]{\{l = e, l_i = e_i\} → \{l = e', l_i = e_i\}}{e → e'} \vspace{1em}
\infer[(Access)]{e.l → e'.l}{e → e'} \vspace{1em}

\subsubsection{Types}
\infer[(Record)]{\{l_i = e_i\}: \{l_i : T_i\}}{e_i : T_i} \vspace{1em}
\infer[(Access)]{\{l = e, l_i = e_i\}.l: T}{e : T} \vspace{1em}



\subsection{Variant}
\[e ::= <l = e> \on{as} T | \on{case} e \on{of} <l_i = x_i> ⇒ e_i \]
\[v ::= <l = v> \on{as} T\]
\[T ::= <l_i: T_i>\]
Note that $l$ here means a label.
Also note that most things indexed with $i$ are assumed to quantify over all the possibilities.

\subsubsection{Contraction}
\infer[(Case)]{\on{case} <l_j = v> \on{of} <l_i = x_i> ⇒ e_i → e_j[x_j/v]}{l_j ∈ \{l_i\}} \vspace{1em}


\subsubsection{Congruence}
\infer[(Case)]{\on{case} e \on{of} <l_i = x_i> ⇒ e_i → \on{case} e' \on{of} <l_i = x_i> ⇒ e_i}{e → e'} \vspace{1em}
\infer[(Variant)]{<l = e> \on{as} T → <l = e'> \on{as} T}{e → e'} \vspace{1em}


\subsubsection{Types}
\infer[(Variant)]{ <l_j = e> \on{as} <l_i : T_i> : <l_i : T_i> }{e_j : T_j \hspace{1em} l_j ∈ {l_i}} \vspace{1em}
\infer[(Case)]{ \on{case} e \on{of} <l_i = x_i> ⇒ e_i : T }{e : <l_i : T_i> \hspace{1em} Γ, x_i : T \vdash e_i : T } \vspace{1em}



\subsection{Sequences}
\[e ::= e; e | unit \]
\[v ::= unit\]
\[T ::= Unit\]

\subsubsection{Contraction}
\infer[(Sequence)]{unit; e → e}{} \vspace{1em}

\subsubsection{Congruence}
\infer[(Sequence)]{e; e₀ → e'; e₀}{e → e'} \vspace{1em}

\subsubsection{Types}
\infer[(Unit)]{ unit: Unit }{} \vspace{1em}
\infer[(Sequence)]{ e₁; e₂ : T }{e₁: Unit \hspace{1em} e₂: T} \vspace{1em}



\subsection{State}
\[e ::= ref(e) | loc(n) | deref(e) | assign(e, e)\]
\[v ::= loc(i) \]
\[σ ::= ∅ | [l = v, σ] \]
\[T ::= Ref T\]
Be aware, that if state is used in combination together with any other feature,
then each rule that has $e → e'$ as a premise actually needs something like $e, σ → e, σ'$
and use the updated store in the conclusion.

\subsubsection{Contraction}
\infer[(Reference)]{ref(v), σ → loc(l), σ'}{l ∈ \on{Free(σ)} \hspace{1em} σ' = [l = v, σ]} \vspace{1em}
\infer[(Assign)]{assign(loc(l), v), σ → unit, σ'}{l \not∈ \on{Free(σ)} \hspace{1em} σ' = σ[l = v] } \vspace{1em}
\infer[(Dereference)]{deref(loc(l)), σ → v, σ}{ σ(l) = v } \vspace{1em}

\subsubsection{Congruence}
\infer[(Reference)]{ref(e), σ → ref(e'), σ'}{ e, σ → e', σ' } \vspace{1em}
\infer[(Dereference)]{deref(e), σ → deref(e'), σ'}{ e, σ → e', σ' } \vspace{1em}
\infer[(AssignLoc)]{assign(e, e₀), σ → assign(e', e₀), σ'}{ e, σ → e', σ' } \vspace{1em}
\infer[(AssignVal)]{assign(v, e), σ → assign(v, e'), σ'}{ e, σ → e', σ' } \vspace{1em}

\subsubsection{Types}
coming soon


\section{Lemmas and Observations and Stuff}

\subsection{Substitution}

\begin{itemize}
\item $x[x/e'] = e'$
\item $y[x/e'] = y$, if $x ≠ y$
\item $(e₁ e₂)[x/e'] = e₁[x/e'] e₂[x/e']$
\item $(λx.e)[x/e'] = λx.e$
\item $(λx.e)[y/e'] = λx.(e[y/e'])$, if $x ≠ y$, and (by uniqueness of variable assumption) $y ∉ \on{FreeVariables}(e)$
\end{itemize}


\subsection{Size and Depth}
$size(e) \ge depth(e)$

\subsection{Diamond Property}
$e → e₁, e → e₂ ⇒ ∃e' e₁ → e', e₂ → e'$

\subsection{Termination}
$e →^* v$ because $e → e' ⇒ size(e) > size(e')$

\subsection{Inversion}
Type of Expression follows from structure.

\subsection{Canonical Forms}
The possible values of a type are known.

\subsection{Progress}
$e:T$ and $e$ is not value then $e → e'$

\subsection{Preservation}
$e:T$, $e→e'$ then $e':T$

\subsection{Soundness}
Progress and Preservation

\subsection{Substitution}
$Γ, x: S \vdash e:T$ and $Γ \vdash s: S$ then $Γ \vdash e[x/s]:T$


\end{document}
